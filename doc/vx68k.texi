\input texinfo                  @c -*- Texinfo -*-
@c %**start of header
@setfilename vx68k.info
@settitle Virtual X68000 Reference Manual
@set VERSION 1.1
@c $Format: "@set REVISION $Revision$" $
@set REVISION 1.11
@c $Format: "@set DATE $Date$" $
@set DATE Sun, 10 Dec 2000 23:18:08 +0900
@c %**end of header

@dircategory Miscellaneous packages
@direntry
* Virtual X68000: (vx68k).      A Sharp X68000 virtual machine.
@end direntry

@dircategory Individual utilities
@direntry
* vx68k: (vx68k.info)Invoking vx68k.
                                Execute X68000 programs.
@end direntry

@ifinfo
This file documents the usage and the internals of Virtual X68000.

Copyright 1999-2000 Hypercore Software Design, Ltd.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
@end ifinfo

@titlepage
@title Virtual X68000 Reference Manual
@subtitle Version @value{VERSION}
@author Kaz Sasayama
@page
@vskip 0pt plus 1filll
Revision @value{REVISION}, updated @value{DATE}.

Copyright @copyright{} 1999-2000 Hypercore Software Design, Ltd.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
@end titlepage

@ifnothtml
@contents
@end ifnothtml

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Virtual X68000

Virtual X68000 is a host-architecture independent emulator of
Sharp X68000 written in C++.

This is Revision @value{REVISION} of the Virtual X68000 Reference
Manual, updated @value{DATE}.  This manual applies to Version
@value{VERSION} of Virtual X68000.
@end ifnottex

@menu
* Introduction::                
* Command Reference::           Invoking commands.
* M68000 Architecture::         Quick look at the M68000 architecture.
* Coding Conventions::          How code is written.
* General purpose components::  Generic components.
* X68000 emulation::            X68000 specific components.
* GTK+ User Interface::         
* Sample Application::          
* Function Index::              Index menu for functions and methods.
* Data Type Index::             Index menu for data types and classes.
* Concept Index::               Index menu for concepts.

@detailmenu
 --- The Detailed Node Listing ---

Command Reference

* Invoking vx68k::              Example command.

M68000 Architecture

* Data Size::                   Data size description.

Virtual X68000 Coding Conventions

* Basic Types::                 Typedefs.

General purpose components

* Memory and I/O::              
* Processor::                   How is a processor constructed?

Memory and I/O

* Class memory::                
* Class memory_address_space::  

Processor

* Context::                     
* Execution Unit::              

Execution Unit

* Instructions::                

X68000 emulation

* Machine::                     
* Human68k::                    

Machine

* Class machine::               
* SCC::                         

@end detailmenu
@end menu

@node Introduction, Command Reference, Top, Top
@chapter Introduction

Virtual X68000 is a virtual machine that emulates a Sharp X68000 system.

Virtual X68000 is written in C++ and uses many templates.

@node Command Reference, M68000 Architecture, Introduction, Top
@chapter Command Reference

While Virtual X68000 is written primarily as a set of reusable class
libraries, a sample program is also provided for demonstration.

This chapter describes the usage of the sample program.

@menu
* Invoking vx68k::              Example command.
@end menu

@node Invoking vx68k,  , Command Reference, Command Reference
@section Invoking @code{vx68k}

@code{vx68k} executes X68000 programs.

@code{vx68k}
[@var{option}]...
[--]
@var{command}
[@var{argument}]...

@subheading Options
@table @asis
@item @samp{-M n}
@itemx @samp{--memory-size=n}
Allocate @var{n} megabytes.

@end table

@node M68000 Architecture, Coding Conventions, Command Reference, Top
@chapter M68000 Architecture

Before describing internals of Virtual X68000, let's review the M68000
architecture.

Readers who is familiar with this architecture can skip this chapter.

@menu
* Data Size::                   Data size description.
@end menu

@node Data Size,  , M68000 Architecture, M68000 Architecture
@section Data Size

In M68000 architecture, a @dfn{byte} is an octet.  A @dfn{word} is two
octets.  A @dfn{long word} is four octets.

@node Coding Conventions, General purpose components, M68000 Architecture, Top
@chapter Virtual X68000 Coding Conventions

@cindex coding convention
This chapter describes the coding conventions used in the Virtual X68000
programs.

@menu
* Basic Types::                 Typedefs.
@end menu

@node Basic Types,  , Coding Conventions, Coding Conventions
@section Basic Types
Virtual X68000 defines several basic types to keep the program
portable. These types are defined in namespace
@code{vm68k::types} and imported in namespace
@code{vm68k}.

@deftp Typedef uint_type
This is a natural unsigned type that can
hold an unsigned word number on M68000. This type is
@code{unsigned int} on all host architectures.
@end deftp

@deftp Typedef uint32_type
This is a natural unsigned type that can
hold an unsigned long word number on M68000. This type is
@code{unsigned int} on host architectures that have
@code{unsigned int} with at least 32-bit.
@end deftp

@deftp Typedef sint_type
@code{sint_type} is a natural signed type that can
hold a signed word number on M68000. This type is
@code{int} on most host architectures, but if the host
architecture cannot represent -0x8000 in that type, i.e. it
does not use 2's complement representation, it is @code{long
int} instead.
@end deftp

@deftp Typedef sint32_type
@code{sint32_type} is a natural signed type that can
hold a signed long word number on M68000. This type is
@code{int} on host architectures that have
@code{int} with at least 32-bit and that can represent
-0x80000000 in that type. Otherwise, it is @code{long
int} if the type can hold -0x80000000, or @code{long
long int} if the compiler is GCC. If no type can hold
-0x80000000 on the architecture, Virtual X68000 cannot be
compiled.
@end deftp

@node General purpose components, X68000 emulation, Coding Conventions, Top
@chapter General purpose components
General purpose components are provided by the library libvm68k.
These components are declared in the namespace vm68k.

@menu
* Memory and I/O::              
* Processor::                   How is a processor constructed?
@end menu

@node Memory and I/O, Processor, General purpose components, General purpose components
@section Memory and I/O

@cindex memory
Memory is an object that can be mapped in an address space.
The class @code{memory} is the abstract base
class for all memory.

Virtual X68000 uses a single address space to access memory
and peripheral devices.

@menu
* Class memory::                
* Class memory_address_space::  
@end menu

@node Class memory, Class memory_address_space, Memory and I/O, Memory and I/O
@subsection Class @code{memory}

@deftp {Abstract Class} memory
This class has methods @code{get_16},
@code{get_8}, @code{get_32},
@code{put_16}, @code{put_8}, and
@code{put_32}. The methods
@code{get_16}, @code{get_8},
@code{put_16}, and @code{put_8}
are pure virtual and must be overridden in derived classes.
Default implementations for @code{get_32} and
@code{put_32} are provided but a derived class
can override those for better performance.
@end deftp

@deftp {Enumeration in @code{memory}} function_code
@end deftp

@deftypeop {Abstract Method} memory uint_type get_16 (function_code @var{fc}, uint32_type @var{address}) const
This method reads a word data from the memory.  @var{address} must be
aligned to a word boundary.
@end deftypeop

@deftypeop {Abstract Method} memory {unsigned int} get_8 (function_code @var{fc}, uint32_type @var{address}) const
This method reads a byte data from the memory.
@end deftypeop

@deftypemethod memory uint32_type get_32 (function_code @var{fc}, uint32_type @var{address}) const
@end deftypemethod

@deftypeop {Abstract Method} memory void put_16 (function_code @var{fc}, uint32_type @var{address}, uint_type @var{value})
@end deftypeop

@deftypeop {Abstract Method} memory void put_8 (function_code @var{fc}, uint32_type @var{address}, unsigned int @var{value})
@end deftypeop

@deftypemethod memory void put_32 (function_code @var{fc}, uint32_type @var{address}, uint32_type @var{value})
@end deftypemethod

@deftp Class default_memory
@end deftp

@node Class memory_address_space,  , Class memory, Memory and I/O
@subsection Class @code{memory_address_space}

@deftp Class memory_address_space
This is a class of address spaces for memory.
@end deftp

@node Processor,  , Memory and I/O, General purpose components
@section Processor
@cindex processor

A processor is made of a pair of a context and an execution
unit. A context represents the dynamic state, which is
updated by program execution. An execution unit represents
the static setting that is not changed while program
execution.

@menu
* Context::                     
* Execution Unit::              
@end menu

@node Context, Execution Unit, Processor, Processor
@subsection Context
@cindex context

The state of the processor is stored in a context. Major
components of a context are a set of registers and a
reference to an address space.

@deftp Class context
This class represents the dynamic part of a processor.
@end deftp

@deftypeivar context registers regs
This variable keeps values of the processor registers.
@end deftypeivar

@deftypemethod context bool supervisor_state () const
This method returns true if this context is in the supervisor state.
@end deftypemethod

@deftypemethod context void set_supervisor_state (bool @var{state})
This method sets the supervisor state to @var{state}.
@end deftypemethod

@deftypemethod context memory::function_code data_fc () const
This method returns the function code for data.
@end deftypemethod

@deftypemethod context memory::function_code program_fc () const
This method returns the function code for programs.
@end deftypemethod

@node Execution Unit,  , Context, Processor
@subsection Execution Unit

@cindex execution unit
Virtual X68000 encapsulates non-dynamic aspects of a M68000
processor into an execution unit.

@deftp Class exec_unit
This class represents the static part of a processor.
@end deftp

@deftypemethod exec_unit instruction_type set_instruction (uint16_type @var{op}, const instruction_type &@var{i})
This method sets an instruction for operation word @var{op} to @var{i}
and returns the previous value.
@end deftypemethod

@deftypemethod exec_unit void step (context &@var{c}) const
This method executes a single instruction in context @var{c}.
@end deftypemethod

@deftypemethod exec_unit void run (context &@var{c}) const
This method executes instructions in context @var{c}.
@end deftypemethod

@menu
* Instructions::                
@end menu

@node Instructions,  , Execution Unit, Execution Unit
@subsubsection Instructions

@cindex instruction handler
An instruction is defined by a function.
This function is called @dfn{instruction handler}.

@node X68000 emulation, GTK+ User Interface, General purpose components, Top
@chapter X68000 emulation
@menu
* Machine::                     
* Human68k::                    
@end menu

@node Machine, Human68k, X68000 emulation, X68000 emulation
@section Machine
@cindex machine

In Virtual X68000, a machine is an abstraction of X68000
hardware and firmware BIOS.

@menu
* Class machine::               
* SCC::                         
@end menu

@node Class machine, SCC, Machine, Machine
@subsection Class machine

These definitions are available in @file{<vx68k/machine.h>}.

@deftp Class machine
This class represents the user-interface independent part of an X68000
hardware and firmware.
@end deftp

@defop Constructor machine machine (size_t @var{memory_size})
This method constructs a machine.
@end defop

@deftp {Abstract Class} console
This class is an abstract interface to the host system.
@end deftp

@node SCC,  , Class machine, Machine
@subsection Z8530 SCC
@cindex SCC, Z8530
@cindex serial communication controller, Z8530
@cindex Z8530 SCC
@cindex COM port
@cindex mouse port

X68000 uses a Zilog Z8530 SCC, or serial communication controller, for a
COM port and a mouse port.

@node Human68k,  , Machine, X68000 emulation
@section Human68k
@cindex Human68k

Virtual X68000 is unique as it also offers functions of the
basic operating system, Human68k.

@node GTK+ User Interface, Sample Application, X68000 emulation, Top
@chapter GTK+ User Interface

This chapter describes the GTK+ implementation of user interface
components.

All components described in this chapter is declared in namespace
@code{vx68k::gtk}.

@deftp Class gtk_console
Implements a console using the GTK+ user interface toolkit.
@end deftp

@node Sample Application, Function Index, GTK+ User Interface, Top
@comment  node-name,  next,  previous,  up
@chapter Sample Application

This chapter describes the implementation of the sample application
@code{vx68k}.

@node Function Index, Data Type Index, Sample Application, Top
@unnumbered Function Index

@printindex fn

@node Data Type Index, Concept Index, Function Index, Top
@unnumbered Data Type Index

@printindex tp

@node Concept Index,  , Data Type Index, Top
@unnumbered Concept Index

@printindex cp

@bye
